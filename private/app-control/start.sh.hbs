
if [ "$(whoami)" != "root" ]; then
	echo "Start script should be executed with root privileges."
	exit 1
fi

syslogProto=`echo '{{syslogUrl}}' | grep -oE '(^[a-z]+):' | grep -oE '[a-z]+'`
syslogHost=`echo '{{syslogUrl}}' | grep -oE '(//.+):' | cut -c3-  | rev | cut -c2- | rev`
syslogPort=`echo '{{syslogUrl}}' | grep -oE '(:[0-9]+)' | cut -c2-`

ID="$(cat /proc/sys/kernel/random/uuid)"

exec 1> >(awk -v id=$ID '{ print id, "=>", $0; fflush(); }' | ncat $syslogHost --$syslogProto $syslogPort) 2>{{{literal '&'}}}1

#
# GENERAL STATE CLEANUP AND CONFIGURATION
#
# Root data directory is {{dataDir}}
#
PROJECT="{{project}}"
APPNAME="{{appName}}"
INSTANCE="{{instance}}"
ETCD_CLUSTER="{{etcdCluster}}"
ETCD_INSTANCE_KEY="/instances/$PROJECT/$APPNAME/$INSTANCE"
NIC=$(/usr/bin/ifconfig | /usr/bin/grep -v PROMISC | /usr/bin/pcregrep -o1 '(ens[0-9]+):')
NORMALNIC=$(/usr/bin/ifconfig |  /usr/bin/grep -w -B1 inet | /usr/bin/pcregrep -o1 '(ens[0-9]+):');

{{#if vlan}}
vlan="{{vlan}}"
{{else}}
vlan=$(curl --silent $ETCD_CLUSTER/v2/keys/networking/{{project}}/vlan | jq -r '.node.value')
{{/if}}

TOTAL_STEPS=$((({{total}}*3)+2))
STEP=1

etcdctl --peers $ETCD_CLUSTER rm $ETCD_INSTANCE_KEY --recursive 2>/dev/null
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/meta_/state "loading" > /dev/null
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/meta_/appName "{{appName}}" > /dev/null
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/meta_/appVersion "{{appVersion}}" > /dev/null
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/meta_/parameters '{{stringify params}}' > /dev/null
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/meta_/totalSteps "$TOTAL_STEPS" > /dev/null
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/meta_/progress "$STEP" > /dev/null
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/meta_/agentUrl "{{agentUrl}}" > /dev/null
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/meta_/id "$ID" > /dev/null

# PULL ALL IMAGES

etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/meta_/state "pulling" > /dev/null
{{#each services}}
echo "Pulling image {{image}}..."
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/meta_/stateDescription "Pulling image {{image}}" > /dev/null
docker pull {{image}} > /dev/nul
echo "Done pulling image {{image}}"
STEP=$((STEP+1))
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/meta_/progress "$STEP" > /dev/null
{{/each}}

# ACTIVATE ALL SERVICES

{{#each services}}

DOCKERNAME="{{service}}-$PROJECT-$INSTANCE"
DOCKERNETNAME="net-$DOCKERNAME"
DOCKERSSHDNAME="sshd-$DOCKERNAME"

etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/meta_/state "activating" > /dev/null
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/meta_/stateDescription "Preparing network for {{service}}" > /dev/null
echo "Preparing network for service {{service}}"

#
# Remove any left-behind instances
#
docker kill $DOCKERNETNAME 2>/dev/null
docker rm $DOCKERNETNAME 2>/dev/null
docker kill $DOCKERNAME 2>/dev/null
docker rm $DOCKERNAME 2>/dev/null
docker kill $DOCKERSSHDNAME 2>/dev/null
docker rm $DOCKERSSHDNAME 2>/dev/null
#
# Prepare the volumes
#
{{#each volumes}}
mkdir -p {{../../dataDir}}/{{../../project}}/{{../../instance}}/{{../service}}{{this}}
{{/each}}
#
# Prepare the network
#
links=""
{{#each links}}
links="$links--link net-{{this}}-$PROJECT-$INSTANCE:{{this}} "
{{/each}}

docker run --privileged \
--name $DOCKERNETNAME \
-h {{service}}.{{../instance}}.{{../project}}.ictu \
$links \
-dti jeroenpeeters/public-networking:latest \
bash -c "/opt/bin/pipework --wait -i eth1;dhclient -v eth1;bash" > /dev/null

sudo /opt/bin/pipework $NIC $DOCKERNETNAME 0/0 @$vlan > /dev/null

while [ 1 ]; do
  pubip=$(docker exec $DOCKERNETNAME ifconfig eth1 | grep "inet addr:" | awk '{print $2}' | awk -F: '{print $2}');
  if [[ $pubip ]]; then
    echo "ip=$pubip"
    break;
  else
    echo "waiting on IP from DHCP for $DOCKERNETNAME"
    sleep 5
  fi
done
STEP=$((STEP+1))
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/meta_/progress "$STEP" > /dev/null

#
# Start the service container
#
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/meta_/stateDescription "Activating service {{service}}"
docker run -d \
--name $DOCKERNAME \
--net="container:$DOCKERNETNAME" \
--log-driver=syslog --log-opt syslog-address={{syslogUrl}} \
--log-opt tag="$DOCKERNAME" \
{{#if mapDocker}}-v /var/run/docker.sock:/var/run/docker.sock -v /usr/bin/docker:/usr/bin/docker{{/if}} \
{{dockervolumes}} \
{{volumesfrom}} \
{{opts}} \
{{attribute "expose" "--expose="}} \
{{#if privileged}}--privileged{{/if}} \
{{#if user}}-u {{user}}{{/if}} \
{{#if mem_limit}}-m {{mem_limit}}{{/if}} \
{{{attribute "environment" "-e "}}} \
-v /etc/localtime:/etc/localtime:ro {{image}} {{command}} > /dev/null

{{#if enable_ssh}}
#
# Start the ssh container
#
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/meta_/stateDescription "Enabling SSH for service {{service}}"
docker pull jeroenpeeters/docker-ssh
docker run -d --name $DOCKERSSHDNAME \
-e CONTAINER=$DOCKERNAME -e AUTH_MECHANISM=noAuth \
-e HTTP_ENABLED=false -e CONTAINER_SHELL=bash \
--net="container:$DOCKERNETNAME" \
-v /var/run/docker.sock:/var/run/docker.sock \
-v $(which docker):/usr/bin/docker \
jeroenpeeters/docker-ssh
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/{{service}}/sshPort "22" > /dev/null
{{/if}}

#
# Publish info about the container to etcd
#
hostname="{{service}}.$INSTANCE.$PROJECT.ictu"
myip=$(docker exec $DOCKERNETNAME ifconfig eth1 | grep "inet addr:" | awk '{print $2}' | awk -F: '{print $2}')
ports=$(docker inspect -f '{{{literal '{{range $p, $conf := .Config.ExposedPorts}}{{$p}} {{end}}'}}}' {{image}} | grep -o -G '[0-9]*')
hostIp=$(ifconfig $NORMALNIC | grep 'inet ' | awk '{ print $2 }')
cid=$(docker inspect -f '{{{literal '{{.Id}}'}}}' $DOCKERNAME)

etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/{{service}}/ip "$myip" > /dev/null
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/{{service}}/hostname "$hostname" > /dev/null
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/{{service}}/ports "${ports/\n/ }" > /dev/null
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/{{service}}/hostIp "$hostIp" > /dev/null
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/{{service}}/dockerContainerName "$DOCKERNAME" > /dev/null
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/{{service}}/dockerContainerId "$cid" > /dev/null
#
# Create DNS entry
#
curl --silent -XPUT $ETCD_CLUSTER/v2/keys/skydns/ictu/{{../project}}/{{../instance}}/{{service}} -d value={\"host\":\"$myip\"} > /dev/null
#
# Add local route
#
route add -host $myip docker0

STEP=$((STEP+1))
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/meta_/progress "$STEP" > /dev/null
{{/each}}


STEP=$((STEP+1))
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/meta_/progress "$STEP" > /dev/null
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/meta_/stateDescription "Checking application health"
{{#each services}}
DOCKERNAME="{{service}}-$PROJECT-$INSTANCE"
DOCKERNETNAME="net-$DOCKERNAME"
if [ "$(docker ps | /usr/bin/pcregrep '\s'$DOCKERNAME)" ]; then
	echo "SUCCESS: $DOCKERNAME is running";
else
	echo "FAILURE: $DOCKERNAME is not running";
fi
if [ "$(docker ps | /usr/bin/pcregrep '\s'$DOCKERNETNAME)" ]; then
	echo "SUCCESS: network for $DOCKERNAME is running";
else
	echo "FAILURE: network for $DOCKERNAME is not running";
fi
{{/each}}

sleep 2

etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/meta_/state "active" > /dev/null
etcdctl --peers $ETCD_CLUSTER set $ETCD_INSTANCE_KEY/meta_/stateDescription "Active" > /dev/null

echo "Application started"
